Thoughts
--------
Recode to a "data structures and algorithms" design, instead of an OO design...
My "objects" aren't really that self-contained. They are just data, to be
manipulated by algorithms...

C++'s job:
-instantiate Node<>'s based on user node functions
-build/execute organisms (lots of function call overhead)
-calculate fitness function (it can be complex)
-maintain population container (can have large memory footprint and overhead)
-determine population statistics (rapid iteration over a large container)
-select and crossover organisms (many rapid selections and manipulations)
-select and poach organisms (as above)
-select and mutate organisms (as above)

Python's job:
-load/save configuration files, parse commandline, emit status data
-set internal parameters from configuration (e.g. mutate rate, etc.)
-thread/process management (C++ library calls should happen in only 1 thread)
-loop through generations (updatefitness(), mutate(), crossover(), poach(), etc.)
-file management for population dumps and handle uploads, etc.
-maintain communication with peers, and exchange organisms
-maintain communication for monitoring and cluster management

C++ Interfaces to expose
------------------------
Functions:
-vgp::evolve() << takes mutation/crossover/reproduce params
-vgp::updatefitness()

-Population container:
 -ctor size parameter
 -resize()
 -sort()
 -stats (avgfitness(), avgdepth(), etc.)
 -element access (see Organism structure below)

-Organism structure:
 -repr()
 -serialize() (with sane representations of state data)
 -stats (depth(), nodes(), etc.)
 -getfitness()

-Nodes container:
 -list of nodes, list of types, stats
 
NOTE: Python does NOT need access to any of the Node<> apparatus itself


VGP overall design
------------------

1. Python script for managing peers

2. Python code for managing evolution

3. Python code for running evolution

4. Python/C++ wrappers for interacting with evolution (SWIG)

5. C++ code for interacting with population (initialization, statistics, sorting, poaching)

6. C++ code for interacting with organisms (fitness, execution, etc.)
-organism::getfitness, etc.

7. C++ code for interacting with nodes (creation, mutation, crossover)
-organism::crossover, etc.

8. C++ code for instantiating nodes using node functions
-Node<> template code for extracting traits of function ptrs, FunctionBinder, etc.

9. C++ node functions (statically linked into libvgp.so)
-written like regular functions and instantiated via:
  vgp::NodeLoader<archive_types> nodeloader(vgp::Nodes).makenode(fptr, "name")

